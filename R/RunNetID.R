#' @title Run NetID Model
#'
#' @description This function generates the weighted gene regulatory network (GRN) using the NetID algorithm. NetID first samples the cells on the PCA space to ensure coverage of the whole manifold. It then aggregates the neighborhoods around each sampled cell on the pruned KNN graph. Finally, the GENIE3 algorithm is run on the aggregated gene expression profiles. The sampling and rational aggregation help denoise cells, maintain major variation, and speed up the GRN generation process.
#'
#' @param sce
#' A SingleCellExperiment object that needs to contain the "count" assay. If it also contains the "spliced" and "unspliced" assays, NetID will run on the "spliced" assay.
#'
#' @param min_counts
#' Minimum detected counts for genes. Genes with counts > min_counts will be preserved.
#' Default: 10.
#'
#' @param varID_res
#' Input if the user already has a varID object in the experiment; otherwise, pruneKnn algorithm needs to be run.
#' Default: NULL.
#'
#' @param knn
#' Number of nearest neighbors.
#' Default: 30.
#'
#' @param regulators
#' A gene list containing the feature names of regulators.
#'
#' @param targets
#' A gene list containing the feature names of targets.
#'
#' @param netID_params
#' A list object that can manually set the parameters for the core algorithm of NetID. Refer to the details of parameters using ?check_netID_params.
#'
#' @param velo
#' If using fate probability inferred results from RNA velocity based method (cellrank), make sure you have run the FateDynamic function before setting this parameter to TRUE.
#' Default: FALSE.
#'
#' @param dynamicInfer
#' If using the fate probability inferred results, make sure you have run the FateDynamic function before setting this parameter to TRUE.
#' Default: FALSE.
#'
#' @param maxState
#' NetID assigns cells to cell fates (lineages) by clustering the cells according to fate probability. Internally, NetID uses Gaussian Mixture Model and BIC to choose the optimal number of clusters. User needs to set the maximum number of clusters.
#' Default: 5.
#'
#' @param cut_off
#' Each cluster is assigned to a cell fate by comparing fate probability fold change (e.g. cell fate A vs. others). A cell fate with fold change > cut_off is assigned to the corresponding cluster.
#' Default: 2.
#'
#' @param unique_assign
#' If uniquely assigning the cell fate to each cluster.
#' Default: FALSE.
#'
#' @param restart
#' RunNetID will automatically run pruneKnn if it can't find the VarID_res.rds in the working directory. If VarID_res.rds already exists and the user still wants to re-run pruneKnn, set restart = TRUE.
#' Default: FALSE.
#'
#' @param work_dir
#' Users can specify the working directory by inputting the address, and the varID object (pruneKnn) will be saved in this directory. Otherwise, the local working directory will be used (getwd()).
#' Default: NULL.
#'
#' @param no_cores
#' The number of cores to be used. Default: NULL.
#'
#' @return A list containing the following objects:
#' @param fate_prob
#' Cell fate probability matrix learned by palantir, saved only when dynamicInfer = TRUE.
#'
#' @param LineageClass
#' The assignment of lineage type to each cell. The palantir fate probability matrix is used for assignment.
#'
#' @param fate_prob_velo
#' Cell fate probability matrix learned by palantir, saved only when dynamicInfer = TRUE.
#'
#' @param LineageClass_velo
#' The assignment of lineage type to each cell. The cellrank fate probability matrix is used for assignment.
#'
#' @param pseudotime
#' The pseudotime for each cell, learned by palantir.
#'
#' @param velocity_pseudotime
#' The pseudotime for each cell, learned by RNA velocity (scVelo).
#'
#' @param GEP
#' NetID inferred aggregated profile on the sampling dataset. Users can manually choose their GRN inference method and run it on this expression profile.
#'
#' @param velo_m and velo_m_aggregate
#' The velocity matrix.
#'
#' @param skeleton
#' A gene regulatory network skeleton (a binary matrix with 1 indicating regulation).
#'
#' @param varID_res
#' A varID object generated by pruneKnn.
#'
#' @examples
#' \dontrun{
#' dyn.out <- RunNetID(sce, regulators = TF, targets = TF, netID_params = list(normalize = FALSE, n_cell = 5000), velo = FALSE, dynamicInfer = FALSE)
#' }
#'
#' @export
#'
#' @title A check function for NetID
#'
#' @description A check function for the RunNetID function. RunNetID provides netID_params; users can specify the desired parameters, which are listed as follows:
#'
#' @param var
#' If using variable gene to calculate principal components, used by geosketch method. Default: FALSE.
#'
#' @param sampled_cells
#' The barcode or ID of sampled cells.
#'
#' @param sketch.method
#' Perform sketching sampling on single cell datasets: "geosketch" or "SeuratSketching".
#'
#' @param ndim
#' Dimensions of PCs, used by geosketch method. Default: 30.
#'
#' @param n_cell
#' The number of sampled cells. Default: 500.
#'
#' @param Threshold_Num
#' The minimum number of nearest neighbors of each seed cell after assignments. Default: 2.
#'
#' @param normalize
#' If performing normalization to the count matrix. Default: FALSE.
#'
#' @param prior_net
#' A binary matrix indicating the prior knowledge of gene regulation, where rows are regulators and columns are targets.
#'
#' @export
#'
 RunNetID <- function (sce, min_counts = 10, varID_res = NULL, knn = 30, regulators = NULL, 
    targets = NULL, netID_params = list(), velo = TRUE, dynamicInfer = TRUE, 
    maxState = 5, cut_off = 2, work_dir = NULL, no_cores = NULL) 
{

    if (!is.null(work_dir)) {
        setwd(work_dir)
    }
    suppressPackageStartupMessages(require("mclust"))
    suppressPackageStartupMessages(require("GENIE3"))
    env = environment()
    netID_params <- check_netID_params(netID_params)
    list2env(netID_params, env)
    if (class(sce) %in% c("SCseq", "Seurat", "SingleCellExperiment") == 
        FALSE) {
        stop("input object needs to be SCseq,Seurat or SingleCellExperiment object, please check again!")
    }
    writeLines(paste("Input object is ", class(sce), "...", sep = ""))
    if (class(sce) == "SingleCellExperiment") {
        a = "counts" %in% names(SummarizedExperiment::assays(sce))
        b = "spliced" %in% names(SummarizedExperiment::assays(sce))
        if (a) {
            sce <- sce[, colSums(as.matrix(SummarizedExperiment::assays(sce)$counts)) > 
                0]
            X <- as.matrix(SummarizedExperiment::assays(sce)$counts)
        }
        if (b) {
            sce <- sce[, colSums(as.matrix(SummarizedExperiment::assays(sce)$spliced)) > 
                0]
            X <- as.matrix(SummarizedExperiment::assays(sce)$spliced)
        }
        if (!a & !b) {
            stop("SingleCellExperiment object has no spliced or counts assay, please check again!")
        }
    }
    if (class(sce) == "Seurat") {
        a = "RNA" %in% names(sce@assays)
        b = "spliced" %in% names(sce@assays)
        if (a) {
            sce <- sce[, colSums(as.matrix(Seurat::GetAssayData(sce, 
                assay = "RNA", layer = "counts"))) > 0]
            X <- as.matrix(Seurat::GetAssayData(sce, assay = "RNA", 
                layer = "counts"))
        }
        if (b) {
            sce <- sce[, colSums(as.matrix(Seurat::GetAssayData(sce, 
                assay = "spliced", layer = "counts"))) > 0]
            X <- as.matrix(Seurat::GetAssayData(sce, assay = "spliced", 
                layer = "counts"))
        }
        if (!a & !b) {
            stop("SingleCellExperiment object has no spliced or RNA assay, please check again!")
        }
    }
    if (class(sce) == "SCseq") {
        X <- as.matrix(RaceID::getExpData(sce, genes=rownames(sce@expdata)))
        X <- X[, colSums(X) > 0]
        if (velo & dynamicInfer) {
            warning("Using velocity dynamic information, but SCseq only save one assay, better use SingleCellExperiment and Seurat!")
        }
    }
    X <- X[!duplicated(rownames(X)), ]
    X <- X[, colSums(X) > 0]
    if (is.null(g)) {
        g <- rownames(X)[rowSums(X) > min_counts]
    }
    if (dynamicInfer) {
        sc <- reticulate::import("scanpy", convert = FALSE)
        adata_exp <- sc$read_h5ad("./output/FateRes.h5ad")
        if (velo) {
            adata_velo <- sc$read_h5ad("./output_velo/FateRes.h5ad")
            velo_m <- t(reticulate::py_to_r(adata_velo$layers["velocity"]))
            rownames(velo_m) <- rownames(reticulate::py_to_r(adata_velo$var))
            colnames(velo_m) <- rownames(reticulate::py_to_r(adata_velo$obs))
        }
        GEP <- t(reticulate::py_to_r(adata_exp$X))
        rownames(GEP) <- rownames(reticulate::py_to_r(adata_exp$var))
        colnames(GEP) <- rownames(reticulate::py_to_r(adata_exp$obs))
        g <- rownames(GEP)
    }
    X <- as.matrix(X)
    if (is.null(varID_res)) {
        if (length(intersect(list.files(getwd()), "varID_res.rds")) == 1) {
            writeLines("Find VarID object at local dictionary, Read VarID object...")
            varID_res <- readRDS("varID_res.rds")
        } else {
            writeLines("Build VarID object...")
            if (is.null(no_cores)) {
                no_cores <- max(1, parallel::detectCores() - 
                  2)
            }
            no_cores <- min(no_cores, parallel::detectCores())
            if (SNN) {
                if (class(sce) != "Seurat") {
                  stop("SNN requires input Seurat object!")
                } else {
                  writeLines("Perform pruning on Seurat SNN graph...")
                  varID_res <- RaceID::pruneKnn(sce[g, ], do.prune = do.prune, 
                    no_cores = no_cores, pca.scale = TRUE, FSelect = TRUE)
                }
            } else {
                varID_res <- RaceID::pruneKnn(X[g, ], knn = as.numeric(knn), 
                  do.prune = do.prune, no_cores = no_cores, pca.scale = TRUE, 
                  FSelect = TRUE)
            }
            saveRDS(varID_res, file = "varID_res.rds")
        }
    }
    regulators <- intersect(regulators, g)
    targets <- intersect(targets, g)
    writeLines("Using NetID to perform skeleton estimation...")
    skeleton <- RunNetID2(spliced = X[g, ], varID_obj = varID_res, 
        var = var, sampled_cells = sampled_cells, sketch.method = sketch.method, 
        n_cell = n_cell, ndim = ndim, regulators = regulators, 
        targets = targets, Threshold_Num = Threshold_Num, normalize = normalize, 
        prior_net = prior_net)
    if (dynamicInfer) {
        fate_prob <- reticulate::py_to_r(adata_exp$obs)
        ID <- colnames(fate_prob)[-ncol(fate_prob)]
        barcode <- rownames(fate_prob)
        fate_prob <- as.matrix(fate_prob[, -ncol(fate_prob)])
        rownames(fate_prob) <- barcode
        colnames(fate_prob) <- ID
        if (velo) {
            fate_prob_velo <- reticulate::py_to_r(adata_velo$obs)
            ID <- colnames(fate_prob_velo)[-ncol(fate_prob_velo)]
            barcode <- rownames(fate_prob_velo)
            fate_prob_velo <- as.matrix(fate_prob_velo[, -ncol(fate_prob_velo)])
            rownames(fate_prob_velo) <- barcode
            colnames(fate_prob_velo) <- ID
            velo_m_aggre <- apply(skeleton$y.final, 2, function(x) {
                f <- colnames(velo_m) %in% rownames(skeleton$y.final)[x > 
                  0]
                rowMeans(as.matrix(velo_m[, f]))
            })
            colnames(velo_m_aggre) <- colnames(skeleton$y.final)
            rownames(velo_m_aggre) <- rownames(velo_m)
        }
        cat("Classify lineage for palantir fate prob...\n")
        if (ncol(fate_prob) == 1) {
            LineageClass <- LineageClassifer(fate_prob, maxState = maxState, 
                cut_off = cut_off)
        }
        else {
            LineageClass <- LineageClassifer(fate_prob, maxState = maxState, 
                cut_off = cut_off)
        }
        if (velo) {
            cat("Classify lineage for cellrank fate prob...\n")
            if (ncol(fate_prob_velo) == 1) {
                LineageClass_velo <- list()
                LineageClass_velo[[colnames(fate_prob_velo)]] <- rownames(fate_prob_velo)
            }
            else {
                LineageClass_velo <- LineageClassifer(fate_prob_velo, 
                  maxState = maxState)
            }
        }
        pseudotime <- reticulate::py_to_r(adata_exp$obs)$pseudotime
        names(pseudotime) <- rownames(reticulate::py_to_r(adata_exp$obs))
        if (velo) {
            velocity_pseudotime <- reticulate::py_to_r(adata_velo$obs)$velocity_pseudotime
            names(velocity_pseudotime) <- rownames(reticulate::py_to_r(adata_velo$obs))
        }
    }
    writeLines("Done...")
    res <- list()
    if (dynamicInfer) {
        res$fate_prob = fate_prob
        res$LineageClass = LineageClass
        if (velo) {
            res$fate_prob_velo = fate_prob_velo
            res$LineageClass_velo = LineageClass_velo
        }
        res$pseudotime <- pseudotime
        if (velo) 
            res$velocity_pseudotime <- velocity_pseudotime
        if (velo) 
            res$velo_m <- velo_m
        if (velo) 
            res$velo_m_aggre <- velo_m_aggre
        res$GEP <- GEP
    }
    res$skeleton <- skeleton
    res$varID_res <- varID_res
    return(res)
}



RunNetID2 <- function (spliced, varID_obj, var = FALSE, sampled_cells = NULL, 
    sketch.method = "SeuratSketching", ndim = 50, n_cell = 500, 
    Threshold_Num = 5, regulators = NULL, targets = NULL, normalize = TRUE, 
    prior_net = NULL) 
{
    if (is.null(sampled_cells)) {
        exp.m = spliced
        sketch.indices = Sketching(exp.m = exp.m, varID_obj = varID_obj, 
            var = var, n_cell = n_cell, sketch.method = sketch.method, 
            ndim = ndim)
    }
    pvalue <- 0.01
    if (is.null(sampled_cells)) {
        id <- sampled_cells <- unlist(sketch.indices)
    }    else {
        id <- sampled_cells
    }
    x <- t(varID_obj$NN)[id, ]
    y <- Matrix::Matrix(rep(0, ncol(varID_obj$NN) * length(id)), 
        ncol = ncol(varID_obj$NN))
    rownames(y) <- rownames(x)
    colnames(y) <- colnames(varID_obj$NN)
    writeLines("prune sampled neighbourhoods according to q-value...")
    for (i in rownames(y)) {
        f <- varID_obj$NN[, i] != 0
        p <- varID_obj$pvM[, i]
        p[p < pvalue] <- 0
        y[i, varID_obj$NN[f, i]] <- c(1, p)[f]
    }
    y <- as.matrix(t(as.matrix(y)))
    y.prune <- y
    y.prune[y.prune != 0] <- 1
    pvalue <- 0
    x <- t(varID_obj$NN)[id, ]
    y <- Matrix::Matrix(rep(0, ncol(varID_obj$NN) * length(id)), 
        ncol = ncol(varID_obj$NN))
    rownames(y) <- rownames(x)
    colnames(y) <- colnames(varID_obj$NN)
    writeLines("assign weight for edges using p-value...")
    for (i in rownames(y)) {
        f <- varID_obj$NN[, i] != 0
        p <- varID_obj$pvM.raw[, i]
        y[i, varID_obj$NN[f, i]] <- c(1, p)[f]
    }
    y <- as.matrix(t(as.matrix(y)))
    y.unprune <- y
    rm(y)
    gc()
    y.weighted <- y.unprune * y.prune
    cs <- rowSums(y.weighted)
    f <- cs > 0
    y.weighted <- y.weighted[f, ]
    count <- apply(y.weighted, 2, function(x) {
        sum(x != 0)
    })
    y.final <- matrix(0, nrow = nrow(y.weighted), ncol = ncol(y.weighted))
    colnames(y.final) <- colnames(y.weighted)
    rownames(y.final) <- rownames(y.weighted)
    id <- rownames(y.weighted)[rownames(y.weighted) %in% colnames(y.weighted) == 
        FALSE]
    for (i in id) {
        vec <- which(y.weighted[i, ] == max(y.weighted[i, ]))
        vec_count <- count[vec]
        y.final[i, vec[which(vec_count == min(vec_count))]] <- 1
    }
    y.final[colnames(y.final), colnames(y.final)] <- diag(ncol(y.final))
    count <- function(x) {
        sum(x != 0)
    }
    y.final <- y.final[, apply(y.final, 2, count) > Threshold_Num]
    ks.final <- apply(y.final, 2, function(x) {
        f <- colnames(spliced) %in% rownames(y.final)[x > 0]
        rowMeans(as.matrix(spliced[, f]))
    })
    colnames(ks.final) <- colnames(y.final)
    rownames(ks.final) <- rownames(spliced)
    g <- unique(c(targets, regulators))
    ks.final <- ks.final[g, ]
    if (normalize) {
        s <- colnames(ks.final)
        g <- rownames(ks.final)
        ks.final <- ks.final %*% diag(10^6/colSums(ks.final))
        colnames(ks.final) <- s
        rownames(ks.final) <- g
    }
    writeLines(paste("aggregated matrix: the number of genes:", 
        nrow(ks.final), "; the number of samples:", ncol(ks.final), 
        sep = ""))
    g_c <- GENIE3::GENIE3(log2(ks.final + 1), nCores = 12, verbose = TRUE, 
        nTrees = 500, regulators = regulators, targets = targets)
    g_c_raw <- g_c
    g_c[g_c < 0.001] <- 0
    g_count <- g_c
    g_count[g_count != 0] <- 1
    rank_n <- apply(as.matrix(rowSums(g_count)), 1, function(x) {
        min(x, 50)
    })
    for (i in 1:nrow(g_c)) {
        g_count[i, ][order(g_c[i, ], decreasing = TRUE)[1:rank_n[i]]] <- 2
    }
    g_count[g_count != 0] = g_count[g_count != 0] - 1
    if (!is.null(prior_net)) {
        g_net = prior_net + g_count
        g_net[g_net != 0] <- g_net[g_net != 0] - 1
    }
    else {
        g_net = g_count
    }
    res <- list(skeleton = g_net, g_c = g_c, GENIE3_net = g_c_raw, 
        metaExp = ks.final, metaCells = sampled_cells, y.final = y.final)
    return(res)
}


LineageClassifer <- function(fate_prob,cut_off=2,maxState = 5, diffvar=TRUE, unique_assign = FALSE){
  sampleID <- rownames(fate_prob)
  cellfate <- colnames(fate_prob)
  #fate_prob <- fate_prob %*% diag(1/colMeans(fate_prob))
  #fate_prob <- diag(1/rowSums(fate_prob)) %*% fate_prob
  rownames(fate_prob) <- sampleID
  colnames(fate_prob) <- cellfate
  fateprob.v <- log2(1.000001+ fate_prob / (1.000001 - fate_prob))
  if(diffvar == TRUE){
    ## default assumes different variance for clusters
    mcl.o <- mclust::Mclust(fateprob.v, G = maxState)
  }
  else {
    mcl.o <- mclust::Mclust(fateprob.v, G = maxState, modelNames = c("E"))
  }
  mu.v <- mcl.o$param$mean
  for(i in 1:nrow(mu.v)){
    if(nrow(mu.v) == 2){
      mu.v[i,] <- mu.v[i,] / mcl.o$param$mean[-i,]
    }else{
      mu.v[i,] <- mu.v[i,] / colMeans(mcl.o$param$mean[-i,])
    }
  }
  colnames(mu.v) <- paste0("cluster",1:ncol(mu.v))
  class <- mcl.o$classification
  class <- paste0("cluster",class)
  print(mu.v)
  if(unique_assign){
    writeLines("Unique assign cell state into a specific lineage...")
    label <- NULL
    for(i in 1:ncol(mu.v)){
      if(max(mu.v[,i])>cut_off){
        label <- c(label, rownames(mu.v)[which.max(mu.v[,i])])
      }else{
        label <- c(label,"uncertain")
      }
    }
    lineage_list <- list()
    drop_fate <- NULL
    for(i in 1:nrow(mu.v)){
      lineage_list[[i]] <- colnames(mu.v)[which(label %in% c("uncertain",rownames(mu.v)[i]))]
      lineage_list[[i]] <- rownames(fate_prob)[which(class %in% lineage_list[[i]])]
      if(length(lineage_list[[i]])==0) drop_fate <- c(drop_fate,i)
    }
    names(lineage_list) <- rownames(mu.v)
    if(!is.null(drop_fate))lineage_list <- lineage_list[-drop_fate]
  }else{
    writeLines("Allow shared cell state between different lineage...")
    label_list <- list()
    for(i in 1:nrow(mu.v)){
      label_list[[i]] <- colnames(mu.v)[which(mu.v[i,]>cut_off)]
    }
    uncertain_cellstate <- colnames(mu.v)[colnames(mu.v) %in% unique(unlist(label_list)) == FALSE]
    for(i in 1:nrow(mu.v)) label_list[[i]] <- c(label_list[[i]],uncertain_cellstate)

    lineage_list <- list()
    drop_fate <- NULL
    for(i in 1:nrow(mu.v)){
      lineage_list[[i]] <- label_list[[i]]
      lineage_list[[i]] <- rownames(fate_prob)[which(class %in% lineage_list[[i]])]
      if(length(lineage_list[[i]])==0) drop_fate <- c(drop_fate,i)
    }
    names(lineage_list) <- rownames(mu.v)
    if(!is.null(drop_fate))lineage_list <- lineage_list[-drop_fate]
  }
  lineage_list
}

Sketching<- function (exp.m, varID_obj, var, n_cell, sketch.method, ndim) 
{
    pca <- t(varID_obj$dimRed)
    sample_m <- NULL
    if (sketch.method == "SeuratSketching") {
        object <- Seurat::CreateSeuratObject(exp.m)
        object <- Seurat::NormalizeData(object)
        object <- Seurat::FindVariableFeatures(object)
    }
    if (sketch.method == "geosketch") {
        if (!is.null(ndim)) {
            geneID <- rownames(exp.m)
            sampleID <- colnames(exp.m)
            rownames(exp.m) <- geneID
            colnames(exp.m) <- sampleID
        }
        if (var) {
            X = t(log(exp.m[varID_obj$B$genes, ] + 1))
        }   else {
            X = t(log(exp.m[varID_obj$pars$genes, ] + 1))
        }
        geosketch <- reticulate::import("geosketch")
        s <- rsvd::rsvd(X, k = ndim)
        pca <- s$u %*% diag(s$d)
    }
    if (sketch.method == "geosketch") {
        X.pcs <- pca
        sketch.indices <- geosketch$gs(X.pcs, as.integer(n_cell), 
            one_indexed = TRUE)
    }
    if (sketch.method == "SeuratSketching") {
        atoms <- Seurat::LeverageScoreSampling(object = object, 
            num.cells = n_cell)
        sketch.indices <- which(colnames(object) %in% colnames(atoms))
    }
    if (sketch.method == "random") {
        sketch.indices <- sample(1:ncol(exp.m), n_cell, replace = FALSE)
    }
    sketch.indices <- unlist(sketch.indices)
    sketch.indices
}
